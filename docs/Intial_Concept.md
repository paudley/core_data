<!--
SPDX-FileCopyrightText: 2025 Blackcat Informatics® Inc.
SPDX-License-Identifier: MIT
-->

# core_data: Current Architecture & Operations Guide

## Overview
core_data packages a production-focused PostgreSQL 17 environment using Docker Compose. The platform builds a custom PostgreSQL image with spatial, graph, auditing, and automation extensions, provisions PgHero for query insights, and ships helper scripts for day-two operations such as backups, tuning, and log analytics. All behavior is driven from version-controlled assets so the stack can be reproduced consistently across environments.

## Repository Layout
```
core_data/
├── .env.example              # Template for environment-specific settings (not committed)
├── docker-compose.yml        # Orchestrates PostgreSQL and PgHero services
├── README.md                 # Quick start and project overview
├── AGENTS.md                 # Contributor quick-reference and runbook pointers
├── backups/                  # Host output directory for logical dumps and reports
├── data/                     # Host-mount roots for persistent Postgres/PgBackRest/PgHero data
├── postgres/
│   ├── Dockerfile            # Builds the custom PostgreSQL image
│   ├── conf/
│   │   ├── postgresql.conf.tpl
│   │   └── pg_hba.conf.tpl   # Rendered during init with envsubst
│   ├── initdb/
│   │   ├── 00-render-config.sh
│   │   ├── 01-init-db-user-creation.sh
│   │   └── 02-enable-extensions.sh
│   └── tools/
│       ├── pgbadger          # CLI used for log analytics
│       └── pgtune.py         # Helper for generating tuned configs
└── scripts/
    ├── daily_maintenance.sh  # Batch workflow for dumps, logs, pgBadger, retention
    ├── manage.sh             # Primary management CLI (wraps docker compose, psql, pgBackRest)
    └── lib/
        └── common.sh         # Shared helper functions (compose wrappers, env loading)
```
`data/` should stay out of version control because it stores live cluster state, PgBackRest archives, and PgHero artifacts. The `backups/` directory is an output target for logical dumps and reports generated by the automation scripts.

## Configuration & Deployment
1. Copy the template: `cp .env.example .env`.
2. Populate values that match your environment, especially credentials and host paths.
3. Build and start the stack:
   ```bash
   ./scripts/manage.sh build-image
   ./scripts/manage.sh up
   ```
4. Verify container health:
   ```bash
   docker compose exec postgres pg_isready
   ./scripts/manage.sh psql -c 'SELECT 1;'
   ```

### Environment Variables
The `.env` file is the single source of truth for runtime tuning. The template documents every variable consumed by the code today.

| Variable | Purpose | Example |
| --- | --- | --- |
| `POSTGRES_SUPERUSER` | Bootstrap superuser role injected into the container. | `postgres` |
| `POSTGRES_SUPERUSER_PASSWORD` | Password for the superuser; required before running the stack. | `change_me` |
| `POSTGRES_DB` | Name of the primary database created by the official entrypoint. | `postgres` |
| `POSTGRES_PORT` | Exposed container port (no host mapping by default). | `5432` |
| `PG_VERSION` | Major PostgreSQL version that drives the Dockerfile build ARG. | `17` |
| `DATABASES_TO_CREATE` | Comma-delimited list of `db:owner:password` tuples consumed by `01-init-db-user-creation.sh`. | `app_main:app_user:secret` |
| `POSTGRES_IMAGE_NAME` / `POSTGRES_IMAGE_TAG` | Optional overrides for tagging the custom image. | `core_data/postgres` / `latest` |
| `AGE_VERSION` | Git ref used when cloning and compiling Apache AGE. | `master` |
| `PG_DATA_DIR` | Host path bound to `/var/lib/postgresql/data`. | `./data/postgres_data` |
| `CORE_DATA_PGBACKREST_REPO_DIR` | Host path bound to `/var/lib/pgbackrest`. | `./data/pgbackrest_repo` |
| `PGHERO_DATA_DIR` | Host storage for PgHero state (currently unused but reserved). | `./data/pghero_data` |
| `PGHERO_USER` / `PGHERO_PASSWORD` | Basic auth credentials for the PgHero UI. | `admin` / `change_me` |
| `PGHERO_PORT` | Host port forwarded to PgHero (`8080` internally). | `8080` |
| `DOCKER_NETWORK_NAME` | Name for the dedicated bridge network. | `core_data_network` |
| `DOCKER_NETWORK_SUBNET` | Subnet allocated to the bridge network; also rendered into `pg_hba.conf`. | `172.25.0.0/16` |
| `TZ` | Time zone shared by containers and rendered into `postgresql.conf`. | `UTC` |

## Image Build & Extensions
`postgres/Dockerfile` extends the official `postgres:<PG_VERSION>-bookworm` image. It installs packaged extensions (`postgis`, `pgvector`, `pgaudit`, `pg_cron`, `pg_repack`, `pgtap`) and compiles Apache AGE plus `pg_squeeze` from source. The image also includes `pgbadger`, `pgbackrest`, and helper scripts under `/opt/core_data`. A container health check ensures `pg_isready` succeeds before dependent services start.

## Cluster Initialization
The official PostgreSQL entrypoint executes the init scripts the first time the volume is empty:
- `00-render-config.sh` renders `postgresql.conf` and `pg_hba.conf` using environment variables, writes a pgBackRest stanza config, and touches a sentinel to keep the step idempotent.
- `01-init-db-user-creation.sh` parses `DATABASES_TO_CREATE` to create roles and databases if they do not yet exist.
- `02-enable-extensions.sh` loops through every non-template database (plus `template1`) to enable the bundled extensions, creates a `core_data_admin` schema, and registers a nightly `pg_cron` job that runs `core_data_admin.refresh_pg_squeeze_targets()`.

## Management CLI (`scripts/manage.sh`)
`manage.sh` is the operator entry point. It loads `.env`, wraps `docker compose`, and executes tooling inside the container as the postgres user. Supported commands today:

| Command | Description |
| --- | --- |
| `build-image` | Build the custom PostgreSQL image defined in `postgres/Dockerfile`. |
| `up` / `down` | Start or stop the compose stack (volumes are preserved). |
| `psql [args]` | Run `psql` in the container with optional arguments. |
| `create-user` / `drop-user` | Manage login roles. |
| `create-db` / `drop-db` | Manage databases and owners. |
| `dump` / `dump-sql` | Produce logical backups in custom or plain format under `/backups`. |
| `restore-dump` | Drop and recreate a database before restoring from a `.dump.gz`. |
| `backup` / `stanza-create` / `restore-snapshot` | Orchestrate pgBackRest backups and restores. |
| `pgtune-config` | Invoke `pgtune.py` to produce `postgresql.pgtune.conf` and reload the server. |
| `pgbadger-report` | Generate HTML log analytics from CSV logs in `/backups`. |
| `daily-maintenance` | Call `daily_maintenance.sh` for dumps, logs, pgBadger, and retention pruning. |
| `provision-qa` | Run a differential backup and restore a named database for QA workflows. |
| `logs` / `status` | Tail container logs or show Compose service status. |
| `help` | Display usage. |

## Operational Automation
`scripts/daily_maintenance.sh` orchestrates a repeatable maintenance window: it dumps every non-template database, generates a plain SQL dump of the primary database, copies CSV and text logs for the day, optionally removes logs from the container, runs pgBadger against the captured logs, and prunes backup directories older than the configured retention period.

`pgBackRest` is configured during initialization. Repository and data directories are host-mounted so that backups survive container rebuilds. The helper commands in `manage.sh` ensure the necessary environment variables (`PGHOST`, `PGUSER`, `PGBACKREST_CONF`) are set before invoking pgBackRest.

PgHero is exposed on the port specified by `PGHERO_PORT` with HTTP basic authentication. Use `docker compose logs pghero` to confirm the app is receiving data once the PostgreSQL container reports healthy.

## Automated Testing
`python -m pytest -k full_workflow` provisions a disposable environment, runs the management commands end-to-end (including `daily-maintenance`, `stanza-create`, `backup`, and the `upgrade` safety check), and tears the stack back down. The fixture generates a throwaway `.env`, unique network/container names, and mounts temporary host directories so the test can run safely on shared machines.

## Current Limitations & Known Gaps
- Major version upgrades are handled by the `upgrade --new-version <ver>` command, which wraps the pgautoupgrade helper. The workflow requires the target pgautoupgrade image and upstream `postgres:<ver>-bookworm` base image to exist; the command aborts early if those tags are unavailable.
- PgHero maintains its own internal SQLite database in-container; the `PGHERO_DATA_DIR` mount is reserved but presently unused by the image.
- The end-to-end pytest smoke test exercises image builds, initialization, backups, daily maintenance, and the upgrade no-op path; it expects Docker to be available locally.

With these guardrails in place, future work can focus on broadening upgrade coverage (e.g., supporting alternative base tags) and tightening automated cleanup of pgBackRest artifacts created during test runs.
